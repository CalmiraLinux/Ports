# Управление программным обеспечением

Calmira GNU/Linux(-libre) - source based дистрибутив GNU/LInux(-libre). Это
значит, что всё программное обеспечение устанавливается только из исходного
кода. Есть и другие подобные дистрибутивы, например - Gentoo. Но там
предоставляют и бинарные, уже собранные пакеты, как и в любом другом
дистрибутиве GNU/Linux. В репозитории Calmira GNU/Linux(-libre), напротив,
собранных пакетов нет. Во-первых, я, как создатель и разработчик этой системы
считаю, что раз уж она source based, то никаких собранных пакетов в ней быть не
должно. Кроме того, у меня нет оборудования для размещения этих пакетов:
первоначально дистрибутив я планировал только для себя, но сейчас видно, что он
постепенно разростается от "дистрибутив только для себя, простая игрушка для
изучения" в "сложный для новичков дистрибутив GNU/Linux(-libre) со своей
особенной философией и принципом работы".

## Основные сведения

Программное обеспечение распространяется в пакетах. *Пакет*, в нашем случае, это
архив, содержащий в себе исходный код программы, а также файлы с инструкциями по
сборке. В качестве таких файлов могут выступать всевозможные `Makefile` и
прочие, предназначенные для определённых систем сборки. Кроме того, в таком
пакете могут содержаться файлы с документацией (обычно содержатся в директории
`doc/` или `docs/`), примерами использования в случае, если в пакете находится
исходный код какой-либо библиотеки или фреймворка (`demos/` или `examples/`) и
опознавательные файлы, а также файлы с доп. информацией о программном
обеспечении (`BUGS`, `README`, `LICENSE`/`COPYING`, etc.), процессе разработки
(`CHANGELOG`, `CODE_OF_CONDUCT`, `HACKING`, etc.), доп. сведениями об установке
(`INSTALL`).

При сборке пакета из исходного кода выполняются следующие действия (отмеченные
курсивом пункты не обязательны, и в большинстве случаев могут отсутствовать).

1. Скачивание архива с исходным кодом;
2. *Проверка контрольных сумм скачанного пакета*;
3. Распаковка пакета, переход в распакованную директорию с необходимыми файлами;
4. *Выполнение действий для подготовки к сборке. Как правило, редактирование
   каких-либо файлов, создание ссылок, применение патчей и пр.*;
5. Конфигурирование пакета. В основном - создание файлов `Makefile`, указание
   основных параметров сборки (например, `--bindir`, `--localstatedir`,
   `--sbindir`, `--disable-static`, `--disable-*`, etc.). В некоторых случаях
   может быть пропущен, либо отсутствовать вообще.
6. Сборка пакета из исходного кода. В некоторых случаях может быть пропущен,
   либо отсутствовать вообще. Например, когда пакет представляет собой набор
   всевозможных скриптов, либо каких-либо файлов, трансляция которых в другой
   формат не требуется. Например: `iana-etc` содержит в себе два файла
   (`services` и `protocols`), которые требуется просто скопировать в директорию
   `/etc` командой `cp`;
7. Установка пакета в систему;
8. *Выполнение действий после установки. Как правило это перемещение файлов в
   другие места, в зависимости от конфигурации и строения системы, на которой
   ведётся установка, создание ссылок, удаление лишних файлов*;
9. Выход из директории с исходным кодом, удаление этой директории и скачанного
   архива с исходным кодом ПО.

На самом деле, это достаточно большая последовательность действий, которая может
подойти "точечно", для сборки какого-то отдельного пакета. Но когда пакетов
программного обеспечения много, то, во-первых, при выполнении команд из
какого-либо пункта последовательности очень легко совершить ошибку (пусть и
основные действия за нас выполняют системы сборки и всевозможные скрипты, такие
как `configure` и прочие, а во-вторых, эта последовательность действий обрастает
ещё одним пунктом, который можно считать *рекурсивным*: это удовлетворение
зависимостей.

К примеру, вы хотиете собрать оконный менеджер `i3-gaps`. Но у него есть
зависимость (об их типах читайте далее), которую можно считать основной. Это X
сервер. И перед сборкой `i3-gaps` у вас должен быть установлен этот X сервер. Но
это название скрывает под собой довольно большое число пакетов. Для сборки иксов
вам требуется сконфигурировать временное окружение, содержащее глобальные
переменные (в BASH они именуются *переменными окружения* и создаются командой
`export`), содержащие определённые данные для сборки Xorg. Потом вам требуется
собрать пакеты `util-macros`, `libXau` и прочие - несколько десятков (это не
считая Xorg Applications, Libraries и Fonts!).

Xorg Libraries зависит от пакета `fontconfig`, поэтому перед сборкой Xorg
Libraries и вообще сервера X вам предётся отвлечься и собрать сначала
`fontconfig`, а уже потом вернуться к иксам. Но и тут засада - `fontconfig`
зависит от `freetype`, поэтому вам сначала необходимо собрать `freetype`, потом
`fontconfig`, а уже потом Xorg Libraries.

Всё становится интереснее, когда вы собираете пакет `mesa`, который зависит от
Xorg Libraries (которые вы уже собрали, а если вы сдались на моменте их сборки,
потому что у вас по каким-то причинам не получилось разрешить его зависимости,
то и `mesa` у вас собрана не будет), `libdrm`, `Mako`, `llvm` и прочих. У
последнего тоже есть зависимости и уж поверьте, они такие же большие, как и сам
`llvm`.

Сложно? На сборку сервера X у меня в первый раз ушёл целый день. Сейчас,
конечно, я могу справиться и за вечер, если всё так же буду собирать его
вручную. Время сборки зависит от многих факторов: от мощности хоста, на котором
идёт сборка, от компилятора, настроек системы, размера этих пакетов,
да даже от уровня подготовленности пользователя. Кроме того, если пользователь
для сборки руководствуется какими-либо руководствами, предположим, BLFS, то
время уходит у него и на навигацию по руководству. И поверьте - на навигацию
уходит много времени, пусть и не больше, чем на сборку.

Сложность не только в том, что у пакетов довольно много зависимостей, и их нужно
удовлетворять вручную. Сложность в тех девяти пунктах, в которые я добавил
десятый - *управление зависимостями*. При наборе команды, которая относится к
какому-либо пункту, легко совершить ошибку, в результате которой пакет либо
будет установлен неправильно, либо на каком-то из этапов будет ошибка.

Кроме того, сложность заключается в удалении пакета из системы. Часть
разработчиков в свои `Makefile` и прочие файлы, содержащие команды для
определённой системы сборки, добавляют инструкции по удалению пакета из системы.
Но большинство разработчиков этим не заморачиваются и не добавляют этих
инструкций и команд. В результате очень сильно усложняется и удаление пакета из
системы. Пользователю придётся самому искать все файлы, принадлежащие нужному
пакету, и вручную их удалять. Он вполне может удалить не тот файл, либо не
удалить что-то, т.е. - совершить ещё одну ошибку, но не при сборке и установке,
а уже при удалении.

И тут читатель этой документации поймёт, что сборка программного обеспечения из
исходного кода и дальнейшее управление этим ПО - довольно сложный и трудоёмкий
процесс. И это я ещё не упомянул тот случай, когда пользователь ставит два
конфликтующих пакета (о типах зависимостей читайте далее), в таком случае
какой-то из них либо не будет работать, либо будет работать некорректно. И
человек, решивший попробовать Calmira GNU/Linux(-libre) удивится и, возможно,
разочаруется в таком дистрибутиве, который **очень** сложен.

Поэтому в помощь таким пользователям (да вообще всем пользователям Calmira) и
была разработана система портов и её менеджеры (например, `cport`). Система
портов содержит в себе скрипты, содержащие необходимые команды для сборки пакета
из исходного кода и его установки в систему, а также файлы с описанием пакета и
списком всех файлов, которые будут установлены в систему. Менеджер системы
портов `cport` взаимодействует с этой системой и позволяет выполнять следующие
действия:

- Сборку и установку пакета;
- Удаление пакета;
- Просмотр информации о пакете;
- Обновление пакета до новой версии.

Хочу заострить внимание пользователя на том, что эти инструменты предназначены
для *автоматизации* сборки пакета из исходного кода (в терминологии системы
портов и `cport` пакет, входящий в СП, называется *"портом"*). Кроме того,
`cport` позволяет выводить информацию о пакете в удобном для человека формате и
ведёт базу данных установленных портов.

Эти два инструмента ***не*** обрабатывают зависимости. Обработка зависимостей
лежит целиком и полностью на пользователе. Однако, даже без этого, СП и `cport`
намного упрощают управление программным обеспечением, собранным из исходного
кода.

## Типы зависимостей

Вот мы и подошли к той теме, которая многим может быть непонятна, но, несмотря
на этом, несколько раз упоминалась в пункте выше.

> *Зависимость* - это пакет, обеспечивающий функциональность другому пакету,
> либо обеспечивающий тому работоспособность.

К примеру, у нас есть пакет `mesa` (порт называется `xorg/x11-minimal/mesa`). Он
зависит от пакета `llvm`, который требуется для сборки драйверов Gallium3D,
nouveau и прочих, а также для swrast, программного растеризатора, который иногда
называют llvmpipe. В данном случае `llvm` - это обязательная зависимость для
`mesa`. В том случае, если Gallium3D, nouveau и swrast вам не нужны, то пакет
`llvm` переходит из статуса необходимых зависимостей в статус опциональных. К
сожалению, ни система портов, ни её менеджер cport не поддерживают такую
"лабильность", поэтому все зависимости, которые необходимы для указанной в
инструкциях по сборке в системе портов конфигурации, имеют статус необходимых.
Каждый порт сопровождается файлом `description` (который в некоторых случаях
может быть и пустым!), а в некоторых случаях и `README.md`. В последнем как
раз-таки и описаны в удобном человекочитабельном формате все особенности сборки
нужного пользователю порта.

В любом случае, сборка различных категорий зависимостей - это решение
пользователя. Однако следует учитывать, что без необходимых зависимостей искомый
порт собран не будет, так как сборка завершится ошибкой на одном из описанных
выше этапов.

Несмотря на это, в системе портов и cport есть следующие группы зависимостей:

1. `required` - необходимые зависимости;
2. `recommend` - рекомендуемые зависимости;
3. `optional` - опциональные (необязательные) зависимости;
4. `conflict` - конфликтующие зависимости.

Далее приводится описание каждой группы зависимостей:

### required

Это необходимые зависимости, без которых исходный пакет/порт не будет работать,
либо не будет собран. НЗ делятся на два типа:

1. Зависимости, обеспечивающие работу исходного пакета;
2. Зависимости, обеспечивающие корректную сборку исходного пакета.

Второй тип относится только к source based дистрибутивам. Как правило, к нему
относятся всевозможные компиляторы и дополнения для них (в примере выше (`mesa`
и `llvm`) пакет `llvm` является необходимой зависимостью, которая обеспечивает
корректную сборку исходного пакета `mesa`).

### recommend

Эти зависимости в некоторых случаях рекомендуется устанавливать, так как они
либо повышают стабильность исходного пакета, либо добавляют какой-либо
функционал. Кроме того, если исходный пакет планируется использовать в связке с
другими пакетами, то у него могут быть рекомендуемые зависимости.

К примеру, если планируется использовать рабочее окружение Plasma или GNOME, и
пользователь собирает пакет `mesa`, то рекомендуемая зависимость у него -
`wayland-protocols`, которую рекомендовано собрать перед сборкой `mesa`, если
планируется использовать его в связке с Plasma/GNOME.

### optional

Опциональные зависимости, как и рекомендуемые, совсем необязательны, но уровень
их важности для исходного пакета ниже, чем у рекомендуемых. Например, одна из
опциональных зависимостей пакета `mesa` - `mesa-demos`, содержащая большое число
каких-то тестов и прочей мишуры.

### conflict

Пакеты, описанные в этом параметре, очень сложно назвать зависимостью. Намного
лучше подойдёт слово, которое является антонимом зависимости. Но из-за
особенностей строения системы портов было решено поместить этот тип пакетов
именно в секцию зависимостей.

Это те пакеты, которые конфликтуют с искомым пакетом. К примеру, есть два
пакета: `foo` и `bar`. Второй конфликтует с первым и описан в параметре
`conflict` у первого. Возможно, что пакеты `foo` и `bar` устанавливают в систему
один и тот же файл, но разных версий. В таком случае при существовании двух
пакетов в системе тот конфликтующий файл будет совместимым с одним пакетом, но
несовместимым с другим, и другой пакет будет работать нестабильно, либо же
вообще не работать. В таком случае лучше не держать в системе оба этих пакета,
так как они могут представлять серьёзные помехи в работе как друг к другу, так и
к операционной системе в целом.

## А что в системе портов?

Для того, чтобы это рассмотреть конкретно и полно, требуется знать строение как
системы портов, так и портов в отдельности. Прочитайте
[../README.md](../README.md), который содержит краткий экскурс в строение
системы портов.

Но сейчас мы рассмотрим только конфигурационный файл `port.toml`, который
содержится в каждом порте и содержит детальную информацию о нём. Этот файл, как
следует из расширения, является TOML конфигом, который содержит в себе 3 секции:

1. `package`;
2. `deps`;
3. `port`.

Сейчас нас интересует секция `deps`, в которой как раз-таки и описываются все
зависимости данного пакета:

```toml
[deps]
required = "рекомендуемые зависимости"
build_required = "рекомендуемые для сборки пакета зависимости"
recommend = "рекомендуемые зависимости"
optional = "опциональные зависимости"
conflict = "конфликтующие зависимости"
```

---

[Назад](intro.md) | [Домой](README.md) | [Далее]()
